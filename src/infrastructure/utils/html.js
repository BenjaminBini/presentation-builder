// src/utils/html.js
// HTML utility functions

/**
 * Escape HTML special characters to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} Escaped HTML string
 */
export function escapeHtml(text) {
  if (!text) return '';
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

/**
 * Validate URL for safe usage in image src attributes
 * Prevents javascript:, data:text/html and other dangerous protocols
 * @param {string} url - URL to validate
 * @returns {string} Safe URL or empty string if invalid
 */
export function sanitizeImageUrl(url) {
  if (!url || typeof url !== 'string') return '';

  const trimmed = url.trim();

  // Allow http and https protocols
  if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
    return trimmed;
  }

  // Allow relative URLs (paths starting with / or not containing :)
  if (trimmed.startsWith('/') || !trimmed.includes(':')) {
    return trimmed;
  }

  // Allow safe data URLs for images only
  // Security note: SVG data URLs (data:image/svg+xml) are allowed because:
  // 1. They are only used in <img> src attributes where scripts don't execute
  // 2. The browser's same-origin policy prevents SVG script execution in <img>
  // 3. SVGs are generated by trusted Draw.io integration, not arbitrary user input
  // If SVGs were used via innerHTML or <object>/<embed>, they would need sanitization
  const safeDataPrefixes = [
    'data:image/png',
    'data:image/jpeg',
    'data:image/jpg',
    'data:image/gif',
    'data:image/svg+xml',
    'data:image/webp',
    'data:image/avif'
  ];

  const lowerUrl = trimmed.toLowerCase();
  for (const prefix of safeDataPrefixes) {
    if (lowerUrl.startsWith(prefix)) {
      return trimmed;
    }
  }

  // Reject all other protocols (javascript:, data:text/html, etc.)
  return '';
}

/**
 * Create an HTML element from a string template
 * @param {string} html - HTML string
 * @returns {Element} DOM element
 */
export function createElement(html) {
  const template = document.createElement('template');
  template.innerHTML = html.trim();
  return template.content.firstChild;
}

/**
 * Sanitize a string for use in CSS (remove potentially dangerous characters)
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
export function sanitizeForCss(str) {
  if (str == null) return '';
  return String(str).replace(/[^a-zA-Z0-9-_]/g, '');
}

/**
 * Sanitize HTML content to prevent XSS while preserving safe formatting tags.
 * Used for WYSIWYG content where HTML structure must be preserved.
 * @param {string} html - HTML string to sanitize
 * @returns {string} Sanitized HTML string
 */
export function sanitizeHtml(html) {
  if (!html || typeof html !== 'string') return '';

  // Create a temporary element to parse the HTML
  const temp = document.createElement('div');
  temp.innerHTML = html;

  // Allowed tags and their allowed attributes
  const allowedTags = {
    p: [],
    strong: [],
    b: [],
    em: [],
    i: [],
    u: [],
    a: ['href', 'class'],
    ul: [],
    ol: [],
    li: [],
    br: [],
  };

  /**
   * Recursively sanitize a node and its children
   */
  function sanitizeNode(node) {
    // Text nodes are safe
    if (node.nodeType === Node.TEXT_NODE) {
      return document.createTextNode(node.textContent);
    }

    // Only process element nodes
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return null;
    }

    const tagName = node.tagName.toLowerCase();

    // If tag is not allowed, return only sanitized children as text
    if (!allowedTags.hasOwnProperty(tagName)) {
      const fragment = document.createDocumentFragment();
      for (const child of node.childNodes) {
        const sanitizedChild = sanitizeNode(child);
        if (sanitizedChild) {
          fragment.appendChild(sanitizedChild);
        }
      }
      return fragment;
    }

    // Create new element with allowed tag
    const newElement = document.createElement(tagName);

    // Copy only allowed attributes
    const allowedAttrs = allowedTags[tagName];
    for (const attr of allowedAttrs) {
      if (node.hasAttribute(attr)) {
        let value = node.getAttribute(attr);

        // Special validation for href - block dangerous protocols
        if (attr === 'href') {
          value = sanitizeLinkUrl(value);
          if (!value) continue; // Skip invalid URLs
        }

        newElement.setAttribute(attr, value);
      }
    }

    // Recursively sanitize children
    for (const child of node.childNodes) {
      const sanitizedChild = sanitizeNode(child);
      if (sanitizedChild) {
        newElement.appendChild(sanitizedChild);
      }
    }

    return newElement;
  }

  // Sanitize all children
  const result = document.createDocumentFragment();
  for (const child of temp.childNodes) {
    const sanitizedChild = sanitizeNode(child);
    if (sanitizedChild) {
      result.appendChild(sanitizedChild);
    }
  }

  // Convert back to HTML string
  const output = document.createElement('div');
  output.appendChild(result);
  return output.innerHTML;
}

/**
 * Trim trailing whitespace, <br> tags, zero-width spaces, and empty paragraphs from HTML.
 * Also trims leading whitespace.
 * @param {string} html - HTML string to trim
 * @returns {string} Trimmed HTML string
 */
export function trimHtml(html) {
  if (!html || typeof html !== 'string') return '';

  let result = html;

  // Remove all zero-width spaces (used for cursor positioning)
  result = result.replace(/\u200B/g, '');
  result = result.replace(/&#8203;/g, '');
  result = result.replace(/&#x200B;/gi, '');

  // Trim leading/trailing whitespace
  result = result.trim();

  // Remove trailing <br>, <br/>, <br /> tags (with optional whitespace)
  result = result.replace(/(\s*<br\s*\/?>\s*)+$/gi, '');

  // Remove leading <br> tags
  result = result.replace(/^(\s*<br\s*\/?>\s*)+/gi, '');

  // Remove trailing empty paragraphs <p></p>, <p>&nbsp;</p>, <p><br></p>
  result = result.replace(/(\s*<p>\s*(<br\s*\/?>|&nbsp;|\s)*<\/p>\s*)+$/gi, '');

  // Remove leading empty paragraphs
  result = result.replace(/^(\s*<p>\s*(<br\s*\/?>|&nbsp;|\s)*<\/p>\s*)+/gi, '');

  // Clean up multiple consecutive <br> tags (more than 2) to just 2
  result = result.replace(/(<br\s*\/?>\s*){3,}/gi, '<br><br>');

  return result;
}

/**
 * Validate and sanitize a URL for use in anchor href attributes.
 * Blocks javascript: and other dangerous protocols.
 * @param {string} url - URL to validate
 * @returns {string} Safe URL or empty string if invalid
 */
export function sanitizeLinkUrl(url) {
  if (!url || typeof url !== 'string') return '';

  const trimmed = url.trim();

  // Allow http and https protocols
  if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
    return trimmed;
  }

  // Allow relative URLs (paths starting with / or # or not containing :)
  if (
    trimmed.startsWith('/') ||
    trimmed.startsWith('#') ||
    !trimmed.includes(':')
  ) {
    return trimmed;
  }

  // Allow mailto: protocol
  if (trimmed.toLowerCase().startsWith('mailto:')) {
    return trimmed;
  }

  // Reject all other protocols (javascript:, data:, vbscript:, etc.)
  return '';
}
