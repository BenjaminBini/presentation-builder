// src/utils/html.js
// HTML utility functions

/**
 * Escape HTML special characters to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} Escaped HTML string
 */
export function escapeHtml(text) {
  if (!text) return '';
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

/**
 * Validate URL for safe usage in image src attributes
 * Prevents javascript:, data:text/html and other dangerous protocols
 * @param {string} url - URL to validate
 * @returns {string} Safe URL or empty string if invalid
 */
export function sanitizeImageUrl(url) {
  if (!url || typeof url !== 'string') return '';

  const trimmed = url.trim();

  // Allow http and https protocols
  if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
    return trimmed;
  }

  // Allow relative URLs (paths starting with / or not containing :)
  if (trimmed.startsWith('/') || !trimmed.includes(':')) {
    return trimmed;
  }

  // Allow safe data URLs for images only
  // Security note: SVG data URLs (data:image/svg+xml) are allowed because:
  // 1. They are only used in <img> src attributes where scripts don't execute
  // 2. The browser's same-origin policy prevents SVG script execution in <img>
  // 3. SVGs are generated by trusted Draw.io integration, not arbitrary user input
  // If SVGs were used via innerHTML or <object>/<embed>, they would need sanitization
  const safeDataPrefixes = [
    'data:image/png',
    'data:image/jpeg',
    'data:image/jpg',
    'data:image/gif',
    'data:image/svg+xml',
    'data:image/webp',
    'data:image/avif'
  ];

  const lowerUrl = trimmed.toLowerCase();
  for (const prefix of safeDataPrefixes) {
    if (lowerUrl.startsWith(prefix)) {
      return trimmed;
    }
  }

  // Reject all other protocols (javascript:, data:text/html, etc.)
  return '';
}

/**
 * Create an HTML element from a string template
 * @param {string} html - HTML string
 * @returns {Element} DOM element
 */
export function createElement(html) {
  const template = document.createElement('template');
  template.innerHTML = html.trim();
  return template.content.firstChild;
}

/**
 * Sanitize a string for use in CSS (remove potentially dangerous characters)
 * @param {string} str - String to sanitize
 * @returns {string} Sanitized string
 */
export function sanitizeForCss(str) {
  if (str == null) return '';
  return String(str).replace(/[^a-zA-Z0-9-_]/g, '');
}

/**
 * Sanitize HTML content to prevent XSS while preserving safe formatting tags.
 * Used for WYSIWYG content where HTML structure must be preserved.
 * @param {string} html - HTML string to sanitize
 * @returns {string} Sanitized HTML string
 */
export function sanitizeHtml(html) {
  if (!html || typeof html !== 'string') return '';

  // Create a temporary element to parse the HTML
  const temp = document.createElement('div');
  temp.innerHTML = html;

  // Allowed tags and their allowed attributes
  const allowedTags = {
    p: [],
    strong: [],
    b: [],
    em: [],
    i: [],
    u: [],
    a: ['href', 'class'],
    ul: [],
    ol: [],
    li: [],
    br: [],
  };

  /**
   * Recursively sanitize a node and its children
   */
  function sanitizeNode(node) {
    // Text nodes are safe
    if (node.nodeType === Node.TEXT_NODE) {
      return document.createTextNode(node.textContent);
    }

    // Only process element nodes
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return null;
    }

    const tagName = node.tagName.toLowerCase();

    // If tag is not allowed, return only sanitized children as text
    if (!allowedTags.hasOwnProperty(tagName)) {
      const fragment = document.createDocumentFragment();
      for (const child of node.childNodes) {
        const sanitizedChild = sanitizeNode(child);
        if (sanitizedChild) {
          fragment.appendChild(sanitizedChild);
        }
      }
      return fragment;
    }

    // Create new element with allowed tag
    const newElement = document.createElement(tagName);

    // Copy only allowed attributes
    const allowedAttrs = allowedTags[tagName];
    for (const attr of allowedAttrs) {
      if (node.hasAttribute(attr)) {
        let value = node.getAttribute(attr);

        // Special validation for href - block dangerous protocols
        if (attr === 'href') {
          value = sanitizeLinkUrl(value);
          if (!value) continue; // Skip invalid URLs
        }

        newElement.setAttribute(attr, value);
      }
    }

    // Recursively sanitize children
    for (const child of node.childNodes) {
      const sanitizedChild = sanitizeNode(child);
      if (sanitizedChild) {
        newElement.appendChild(sanitizedChild);
      }
    }

    return newElement;
  }

  // Sanitize all children
  const result = document.createDocumentFragment();
  for (const child of temp.childNodes) {
    const sanitizedChild = sanitizeNode(child);
    if (sanitizedChild) {
      result.appendChild(sanitizedChild);
    }
  }

  // Convert back to HTML string
  const output = document.createElement('div');
  output.appendChild(result);
  return output.innerHTML;
}

/**
 * Check if a DOM element is empty (contains only whitespace, <br>, or &nbsp;).
 * Handles nested cases like <p><u><b><br></b></u></p>.
 * @param {Node} element - DOM node to check
 * @returns {boolean} True if element is empty
 */
function isEmptyElement(element) {
  if (element.nodeType === Node.TEXT_NODE) {
    return !element.textContent.trim();
  }
  if (element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  const tagName = element.tagName.toLowerCase();
  if (tagName === 'br') {
    return true;
  }
  // Check if element contains only whitespace, <br>, or &nbsp;
  const text = element.textContent.replace(/\u00A0/g, '').trim();
  if (text) {
    return false;
  }
  // Element has no meaningful text, check if it only has empty children
  const hasOnlyEmptyChildren = Array.from(element.childNodes).every(child => {
    if (child.nodeType === Node.TEXT_NODE) {
      return !child.textContent.trim();
    }
    if (child.nodeType === Node.ELEMENT_NODE) {
      return child.tagName.toLowerCase() === 'br' || isEmptyElement(child);
    }
    return true;
  });
  return hasOnlyEmptyChildren;
}

/**
 * Check if element is an inline formatting element.
 * @param {Element} element - DOM element
 * @returns {boolean}
 */
function isInlineFormattingElement(element) {
  const inlineTags = ['b', 'i', 'u', 'strong', 'em', 'a', 'span'];
  return inlineTags.includes(element.tagName.toLowerCase());
}

/**
 * Recursively trim leading <br> tags from within an element.
 * Handles cases like <p><b><br><br>D</b></p> -> <p><b>D</b></p>
 * @param {HTMLElement} element - Element to trim within
 */
function trimLeadingBrWithinElement(element) {
  while (element.firstChild) {
    const first = element.firstChild;

    if (first.nodeType === Node.TEXT_NODE) {
      if (!first.textContent.trim()) {
        first.remove();
        continue;
      }
      // Has text content, stop
      break;
    }

    if (first.nodeType === Node.ELEMENT_NODE) {
      if (first.tagName.toLowerCase() === 'br') {
        first.remove();
        continue;
      }
      // Recurse into inline formatting elements
      if (isInlineFormattingElement(first)) {
        trimLeadingBrWithinElement(first);
        // After trimming, if element is now empty, remove it
        if (isEmptyElement(first)) {
          first.remove();
          continue;
        }
      }
      // Has content, stop
      break;
    }

    first.remove();
  }
}

/**
 * Trim leading empty elements from a container (DOM-based).
 * Handles nested cases like <p><u><b><br></b></u></p>.
 * Also trims leading <br> from within the first non-empty element.
 * @param {HTMLElement} container - Container element
 */
function trimLeadingEmptyNodes(container) {
  while (container.firstChild) {
    const first = container.firstChild;
    if (first.nodeType === Node.TEXT_NODE) {
      if (!first.textContent.trim()) {
        first.remove();
        continue;
      }
      break;
    }
    if (first.nodeType === Node.ELEMENT_NODE) {
      if (isEmptyElement(first)) {
        first.remove();
        continue;
      }
      // First non-empty element - trim leading <br> from within it
      trimLeadingBrWithinElement(first);
      break;
    }
    first.remove();
  }
}

/**
 * Trim trailing empty elements from a container (DOM-based).
 * Handles nested cases like <p><u><b><br></b></u></p>.
 * @param {HTMLElement} container - Container element
 */
function trimTrailingEmptyNodes(container) {
  while (container.lastChild) {
    const last = container.lastChild;
    if (last.nodeType === Node.TEXT_NODE) {
      if (!last.textContent.trim()) {
        last.remove();
        continue;
      }
      break;
    }
    if (last.nodeType === Node.ELEMENT_NODE) {
      if (isEmptyElement(last)) {
        last.remove();
        continue;
      }
      break;
    }
    last.remove();
  }
}

/**
 * Trim trailing whitespace, <br> tags, zero-width spaces, and empty paragraphs from HTML.
 * Also trims leading whitespace. Handles nested empty elements like <p><u><b><br></b></u></p>.
 * @param {string} html - HTML string to trim
 * @returns {string} Trimmed HTML string
 */
export function trimHtml(html) {
  if (!html || typeof html !== 'string') return '';

  let result = html;

  // Remove all zero-width spaces (used for cursor positioning)
  result = result.replace(/\u200B/g, '');
  result = result.replace(/&#8203;/g, '');
  result = result.replace(/&#x200B;/gi, '');

  // Trim leading/trailing whitespace
  result = result.trim();

  // Use DOM-based trimming for leading/trailing empty elements (handles nested cases)
  const temp = document.createElement('div');
  temp.innerHTML = result;

  trimLeadingEmptyNodes(temp);
  trimTrailingEmptyNodes(temp);

  result = temp.innerHTML;

  // Clean up multiple consecutive <br> tags (more than 2) to just 2
  result = result.replace(/(<br\s*\/?>\s*){3,}/gi, '<br><br>');

  return result;
}

/**
 * Validate and sanitize a URL for use in anchor href attributes.
 * Blocks javascript: and other dangerous protocols.
 * @param {string} url - URL to validate
 * @returns {string} Safe URL or empty string if invalid
 */
export function sanitizeLinkUrl(url) {
  if (!url || typeof url !== 'string') return '';

  const trimmed = url.trim();

  // Allow http and https protocols
  if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {
    return trimmed;
  }

  // Allow relative URLs (paths starting with / or # or not containing :)
  if (
    trimmed.startsWith('/') ||
    trimmed.startsWith('#') ||
    !trimmed.includes(':')
  ) {
    return trimmed;
  }

  // Allow mailto: protocol
  if (trimmed.toLowerCase().startsWith('mailto:')) {
    return trimmed;
  }

  // Reject all other protocols (javascript:, data:, vbscript:, etc.)
  return '';
}
